Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Катедра програмної інженерії



ЗВІТ
до лабораторної роботи № 4
з дисципліни «Аналіз та рефакторинґ коду»
на тему: «Створення IоT клієнта»




     Виконала
     ст. гр. ПЗПІ-23-8
     Бут А. Ю.

     Перевірив
     асистент катедри ПІ
Дашенков Д. С.               



Харків 2025

     1 ЗАВДАННЯ
     
     Отримати практичні навички з розробки IoT клієнта, включаючи проектування його архітектури, бізнес логіки, налаштувань, та інтеграцію із серверною частиною. Навчитися використовувати UML для створення діаграм прецедентів та діяльності, а також перевіряти функціональність IoT клієнта через тестування та інтеграцію.
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

     2 ОПИС ВИКОНАНОЇ РОБОТИ
     2.1 Будова програмного забезпечення IoT клієнта
     
     IoT-клієнт системи Ecofy реалізується у вигляді програмно-апаратного комплексу, призначеного для автоматичного контролю стану сміттєвого контейнера та передачі відповідних даних до серверної частини системи. Бізнес-логіка IoT-клієнта визначає правила збору, обробки та передавання даних, а також реакцію пристрою на аварійні ситуації.
     IoT-пристрій складається з таких основних компонентів:
* мікроконтролер (ESP32), який виконує керування датчиками, обробку даних та мережеву взаємодію;
* датчики, що використовуються для контролю його стану (ультразвуковий датчик HC-SR04, що відповідає за перевірку рівня заповненості, датчик нахилу/руху MPU6050 (акселерометр + гіроскоп), цифровий температурний датчик DS18B20);
* модуль бездротового зв’язку, вбудований у мікроконтролер, для передавання даних через WI-FI;
* програмне забезпечення IoT -клієнта, яке реалізує бізнес-логіку, обробку подій та взаємодію з сервером.
     Для реалізації IoT-клієнта застосовуються такі технології:
* ESP32 як апаратна платформа IoT-пристрою;
* мова програмування C/C++ (Arduino Framework) для написання прошивки;
* протокол HTTPS для захищеної передачі телеметричних даних;
* REST API для взаємодії з серверною частиною системи Ecofy;
* JWT / токени доступу для ідентифікації IoT-пристрою.
     На етапі розробки та тестування IoT-клієнта використовується онлайн-симулятор Wokwi, який дозволяє імітувати роботу мікроконтролера та підключених до нього датчиків без використання фізичного обладнання.
     

     2.2 UML діаграма прецедентів для IoT клієнта
     
     UML-діаграма прецедентів IoT-клієнта відображає основні сценарії взаємодії програмного забезпечення пристрою з сенсорами та серверною частиною системи Ecofy (див. рис. 2.1). IoT-клієнт виконує функції збору, обробки та передачі телеметричних даних, а також забезпечує їх буферизацію у разі втрати мережевого з’єднання. Взаємодія з адміністратором здійснюється опосередковано через сервер, який надсилає конфігураційні параметри та керуючі команди.
     

Рисунок 2.1 – UML діаграма прецедентів

     Діаграма прецедентів дозволяє наочно визначити межі відповідальності IoT-клієнта та відокремити його функціональність від серверної бізнес-логіки й користувацьких інтерфейсів системи.

     2.3 Бізнес логіка та функції налаштування IoT клієнта
     
     Основна бізнес-логіка IoT-клієнта системи Ecofy визначає порядок роботи пристрою з даними, отриманими від сенсорів, а також правила взаємодії з серверною частиною системи. IoT-клієнт функціонує в автономному режимі та забезпечує безперервний збір і передачу інформації про стан сміттєвого контейнера.
     До основних етапів бізнес-логіки належать:
* зчитування даних із пристроїв, що характеризують стан контейнера (рівень заповненості, нахил, технічний стан).
* перевірка та попередня обробка даних, яка включає валідацію показників, фільтрацію аномальних значень і обчислення основних параметрів стану контейнера.
* формування телеметричних пакетів, що містять узагальнену інформацію про стан контейнера та IoT -пристрою.
* передавання даних на сервер через захищене мережеве з’єднання з отриманням підтвердження успішної доставки.
* обробка помилок і збоїв зв’язку, що передбачає локальне збереження телеметрії та повторне передавання після відновлення з’єднання.
     IoT-клієнт підтримує механізми налаштування, що дозволяють адаптувати роботу пристрою до умов експлуатації без фізичного втручання.
     До основних функцій налаштування належать:
* конфігурування мережі, що передбачає налаштування параметрів підключення до бездротової мережі, повторне підключення у разі втрати зв’язку та перевірку доступності серверної частини системи;
* налаштування параметрів підключення до сервера, яке включає встановлення адреси серверного API, параметрів автентифікації та інтервалів передавання телеметричних даних;
* керування параметрами збору даних, що полягає у налаштуванні періодичності зчитування сенсорів, порогових значень рівня заповненості контейнера та параметрів обробки даних.
     Усі налаштування можуть зберігатися локально на IoT-пристрої та оновлюватися дистанційно з серверної частини системи.
     
     2.4 UML діаграма діяльності для IoT клієнта
     
     UML-діаграма діяльності відображає послідовність виконання основних процесів IoT-клієнта системи Ecofy. Після ініціалізації та встановлення мережевого з’єднання пристрій (див. рис. 2.2) переходить у циклічний режим роботи, у межах якого виконується зчитування даних із датчиків (див. рис. 2.3), визначення рівня заповнення контейнера та перевірка його стану. IoT-клієнт здійснює контроль власного технічного стану та, у разі виявлення помилок, формує і передає відповідні повідомлення на сервер (див. рис. 2.4). Оброблені дані передаються до серверної частини системи або тимчасово зберігаються у локальній пам’яті за відсутності мережевого з’єднання (див. рис. 2.5).

Рисунок 2.2 – Ініціалізація та перехід у режим роботи

Рисунок 2.3 – Збір та перевірка даних з датчиків

     Рисунок 2.4 – Контроль технічного стану та передавання повідомлень про помилки
     

Рисунок 2.5 – Формування та передавання телеметрії
     
     Така організація діяльності забезпечує автономність, надійність та стійкість IoT-клієнта до збоїв зв’язку.
     
     2.5 Програмна реалізація бізнес логіки та функцій налаштування IoT клієнта
     
     Програмна реалізація бізнес-логіки підсистеми роботи з IoT-пристроями побудована за клієнт-серверною архітектурою та охоплює процеси реєстрації пристроїв, приймання телеметричних даних, їх обробки, аналізу та формування подій і сповіщень. Серверна частина системи реалізована з використанням фреймворку FastAPI та забезпечує централізоване керування IoT-інфраструктурою.
     Ключовим елементом серверної логіки є обробка телеметрії, яка надходить від IoT-клієнтів. Під час приймання телеметричних даних виконується ідентифікація пристрою за серійним номером, перевірка його прив’язки до контейнера, нормалізація отриманих значень та оновлення поточного стану як пристрою, так і контейнера. Реалізація цього функціоналу наведена у Додатку Б.1.
     У системі також реалізовано набір правил, відповідно до яких генеруються попереджувальні або критичні повідомлення:
* рівень заповнення ? 90 % ;
* нахил контейнера;
* температура: ? 45 °c –  попередження, ? 60 °c – критичне повідомлення;
* рівень батареї пристрою: ? 20 % –  попередження, ? 10 % –  критичне повідомлення.
     Логіка формування сповіщень реалізована окремими функціями та також представлена у Додатках Б.2 – Б..
     IoT-клієнт реалізовано на базі ESP32 та виконує локальну обробку сенсорних даних з подальшою передачею на сервер.
     Клієнт здійснює:
* вимірювання температури за допомогою DS18B20;
* визначення рівня заповнення контейнера через HC-SR04;
* виявлення нахилу контейнера з використанням MPU6050.
     Усі вимірювання виконуються з фіксованим інтервалом часу (READ_INTERVAL_MS).
     До функцій конфігурування IoT-клієнта належать налаштування мережевого з’єднання, параметрів взаємодії з серверною частиною системи та управління енергоспоживанням пристрою. Підключення до Wi-Fi здійснюється під час ініціалізації клієнта з виведенням статусу з’єднання та IP-адреси у серійну консоль. Параметри підключення, зокрема інтервали зчитування сенсорів та ідентифікаційні дані пристрою, задаються через конфігураційні змінні та можуть бути змінені на етапі компіляції. Контроль енергоспоживання реалізовано у вигляді моніторингу рівня заряду батареї, що в подальшому може бути розширено шляхом впровадження режимів зниженого енергоспоживання. Програмна реалізація IoT-клієнта наведена у Додатку Б.
     

Рисунок 2.6 - Перелік endpoints модуля керування IoT-пристроями
     
     Таким чином, реалізована програмна логіка забезпечує повний цикл взаємодії між IoT-клієнтом та серверною частиною системи.
     
     2.6 Перевірка роботи IoT клієнта
     
     У межах розробки було використано симулятор Wokwi, який дозволяє емулювати роботу IoT-пристрою (див. рис. 2.7). Значення сенсорів (температура, рівень наповнення, нахил) задаються вручну через інтерфейс (див. рис. 2.8-2.10 ) симулятора та використовуються для перевірки бізнес-логіки системи.
     У процесі тестування IoT-клієнт коректно зчитував задані значення сенсорів, виконував локальну обробку даних та виводив результати у серійну консоль симулятора. У консолі відображалася інформація про успішне підключення до бездротової мережі Wi-Fi, ініціалізацію сенсорів, поточні значення рівня заповнення контейнера, температури, стану нахилу та рівня заряду батареї, а також статус мережевого з’єднання. Приклад результатів роботи IoT-клієнта наведено на рис. 2.11.
     

     Рисунок 2.7 - Апаратна схема IoT-клієнта системи Ecofy на базі мікроконтролера ESP32


Рисунок 2.8 – Налаштування параметрів для сенсору HC-SR04


Рисунок 2.9 – Налаштування параметрів для сенсору DS18B20


Рисунок 2.10 – Налаштування параметрів для сенсору MPU6050

     
Рисунок 2.11 – Результати роботи IoT-клієнта в середовищі симулятора Wokwi
     
      Отримані результати підтвердили коректність реалізації програмної логіки IoT-клієнта, правильність зчитування та обробки даних сенсорів, а також працездатність механізмів мережевої ініціалізації та виведення телеметрії.
      
      
      
      
     ВИСНОВКИ
     
     У ході виконання завдання було розроблено та протестовано IoT-клієнт для системи Ecofy, що забезпечує збір, обробку та передавання телеметричних даних від сенсорів до серверної частини системи. Побудована архітектура, реалізована бізнес-логіка та механізми конфігурування клієнта підтвердили можливість його автономної та надійної роботи. Використання симулятора Wokwi дозволило ефективно перевірити функціональність IoT-клієнта та відпрацювати сценарії його інтеграції із серверною частиною.





















ДОДАТОК А
Відеозапис

     Відеозвіт з лабораторної роботи: https://youtu.be/tStYYcG5gaM


























ДОДАТОК Б
Програмний код

     GitHub репозиторій: https://github.com/NureButAnna/ark-pzpi-23-8-but-anna/tree/main/Task4/ark-pzpi-23-8-but-anna-task4/src
     Б.1 Endpoint, який приймає телеметричні дані IoT-пристрою, оновлює стан контейнера та ініціює перевірки критичних показників.
     
1 @router.post("/telemetry")
2 def receive_telemetry(
3 data: DeviceTelemetry,
4 db: Session = Depends(get_db)
5 ):
6 device = db.query(Devices).filter(
7 Devices.serial_number == data.serial_number
8 ).first()
      
9 if not device:
10 raise HTTPException(404, "Device not registered")
      
11 if not device.container_id:
12 raise HTTPException(409, "Device not bound to container")
      
13 container = db.query(Containers).filter(
14 Containers.container_id == device.container_id
15 ).first()
      
16 fill_level = max(0, min(data.fill_level, 100))
17 temperature = max(-40, min(data.temperature, 120))
18 battery_level = max(0, min(data.battery_level, 100))
      
19 device.last_signal = datetime.utcnow()
20 device.battery_level = battery_level
21 device.status = "active"
      
22 container.fill_level = fill_level
23 container.temperature = temperature
24 container.tilted = data.tilted
25 container.last_update = datetime.utcnow()
      
26 check_fill_level(fill_level, container, db)
27 check_tilt(data.tilted, container, db)
28 check_temperature(temperature, container, db)
29 check_battery(battery_level, device, db)
      
30 db.commit()
31 return {"status": "ok"}

     
     GitHub репозиторій: https://github.com/NureButAnna/ark-pzpi-23-8-but anna/tree/main/Task4/ark-pzpi-23-8-but-anna-task4/src
     Б.2  Функція контролю рівня заповненості контейнера

1 def check_fill_level(fill_level: float, container, db: Session):
2     if fill_level >= 90:
3         db.add(Notifications(
4             message="Контейнер майже заповнений",
5             message_type="WARNING",
6             container_site_id=container.container_site_id
7         ))

     GitHub репозиторій: https://github.com/NureButAnna/ark-pzpi-23-8-but-anna/tree/main/Task4/ark-pzpi-23-8-but-anna-task4/src
     Б.3 Функція контролю нахилу контейнера


1 def check_tilt(tilted: bool, container, db: Session):
2     if tilted:
3         db.add(Notifications(
4             message="Контейнер нахилений",
5             message_type="CRITICAL",
6             container_site_id=container.container_site_id
7         ))
     
     GitHub репозиторій: https://github.com/NureButAnna/ark-pzpi-23-8-but-anna/tree/main/Task4/ark-pzpi-23-8-but-anna-task4/src
     Б.4 Функція контролю температурного режиму контейнера

1 def check_temperature(temperature: float, container, db: Session):
2     if temperature >= 60:
3         db.add(Notifications(
4             message=f"Критично висока температура в контейнері ({temperature} °C)",
5             message_type="CRITICAL",
6             container_site_id=container.container_site_id
7         ))
8     elif temperature >= 45:
9         db.add(Notifications(
10             message=f"Підвищена температура в контейнері ({temperature} °C)",
11             message_type="WARNING",
12             container_site_id=container.container_site_id
13         ))


     GitHub репозиторій: https://github.com/NureButAnna/ark-pzpi-23-8-but-anna/tree/main/Task4/ark-pzpi-23-8-but-anna-task4/src
     Б.5 Функція контролю рівня заряду батареї пристрою

1 def check_battery(battery_level: int, device, db: Session):
2     if battery_level <= 10:
3         db.add(Notifications(
4             message="Критично низький рівень заряду батареї пристрою",
5             message_type="CRITICAL",
6             container_site_id=device.container.container_site_id
7         ))
8     elif battery_level <= 20:
9         db.add(Notifications(
10             message="Низький рівень заряду батареї пристрою",
11             message_type="WARNING",
12             container_site_id=device.container.container_site_id
13         ))











     GitHub репозиторій: https://github.com/NureButAnna/ark-pzpi-23-8-but-anna/tree/main/Task4/ark-pzpi-23-8-but-anna-task4/IoT
     Б.6 Програмний код IoT-клієнта для зчитування телеметричних даних контейнера
     
1 #include <OneWire.h>
2 #include <DallasTemperature.h>
3 #include <Wire.h>
4 #include <MPU6050.h>
5 #include <WiFi.h>

6 /* ---------- WiFi ---------- */
7 const char* ssid = "Wokwi-GUEST";
8 const char* password = "";

9 /* ---------- DS18B20 ---------- */
10 #define TEMP_PIN 4
11 OneWire oneWire(TEMP_PIN);
12 DallasTemperature tempSensor(&oneWire);

13 /* ---------- HC-SR04 ---------- */
14 #define TRIG_PIN 5
15 #define ECHO_PIN 18

16 /* ---------- MPU6050 ---------- */
17 MPU6050 mpu;

18 /* ---------- CONTAINER ---------- */
19 const float containerHeightCm = 100.0;

20 /* ---------- SETTINGS ---------- */
21 const uint32_t READ_INTERVAL_MS = 3000;
22 uint32_t lastRead = 0;

23 /* ---------- ULTRASONIC ---------- */
24 float readDistanceCm() {
25 digitalWrite(TRIG_PIN, LOW);
26 delayMicroseconds(2);
27 digitalWrite(TRIG_PIN, HIGH);
28 delayMicroseconds(10);
29 digitalWrite(TRIG_PIN, LOW);

30 long duration = pulseIn(ECHO_PIN, HIGH, 30000);
31 if (duration == 0) return -1;

32 return duration * 0.034 / 2.0;
33 }

34 float readFillLevelPercent() {
35 float distance = readDistanceCm();
36 if (distance < 0) return -1;

37 float fill = (containerHeightCm - distance) / containerHeightCm * 100.0;
38 return constrain(fill, 0, 100);
39 }

40 /* ---------- MPU ---------- */
41 bool readTilted() {
42 int16_t ax, ay, az;
43 mpu.getAcceleration(&ax, &ay, &az);

44 float fx = ax / 16384.0;
45 float fy = ay / 16384.0;

46 return (abs(fx) > 0.3 || abs(fy) > 0.3);
47 }

48 /* ---------- TEMPERATURE ---------- */
49 float readTemperature() {
50 tempSensor.requestTemperatures();
51 float temp = tempSensor.getTempCByIndex(0);

52 if (temp == DEVICE_DISCONNECTED_C) {
53 Serial.println("DS18B20 disconnected");
54 return -100;
55 }
56 return temp;
57 }

58 /* ---------- SETUP ---------- */
59 void setup() {
60 Serial.begin(115200);
61 delay(1000);

62 pinMode(TRIG_PIN, OUTPUT);
63 pinMode(ECHO_PIN, INPUT);

64 /* WiFi */
65 WiFi.begin(ssid, password);
66 Serial.print("Connecting to WiFi");

67 while (WiFi.status() != WL_CONNECTED) {
68 delay(500);
69 Serial.print(".");
70 }

71 Serial.println("\n WiFi connected");
72 Serial.print("IP address: ");
73 Serial.println(WiFi.localIP());

74 /* Sensors */
75 Wire.begin(21, 22);
76 mpu.initialize();
77 tempSensor.begin();

78 Serial.println(mpu.testConnection()
79 ? "MPU6050 connected"
80 : "MPU6050 NOT found");

81 Serial.println("DS18B20 initialized");
82 Serial.println("----------------------------------");
83 }

84 /* ---------- LOOP ---------- */
85 void loop() {
86 if (millis() - lastRead >= READ_INTERVAL_MS) {
87 lastRead = millis();

88 float fill = readFillLevelPercent();
89 float temperature = readTemperature();
90 bool tilted = readTilted();
91 int battery = random(60, 100); // емітація батареї

92 if (fill < 0) fill = 0;
93 if (temperature < -50) temperature = 0;

94 Serial.println("\n--- SENSOR DATA ---");

95 Serial.print("Fill level: ");
96 Serial.print(fill);
97 Serial.println(" %");

98 Serial.print("Temperature: ");
99 Serial.print(temperature);
100 Serial.println(" °C");

101 Serial.print("Tilted: ");
102 Serial.println(tilted ? "YES" : "NO");

103 Serial.print("Battery: ");
104 Serial.print(battery);
105 Serial.println(" %");

106 Serial.print("WiFi status: ");
107 Serial.println(WiFi.status() == WL_CONNECTED ? "CONNECTED" : "DISCONNECTED");

108 Serial.println("-------------------");
109 }
110 }
