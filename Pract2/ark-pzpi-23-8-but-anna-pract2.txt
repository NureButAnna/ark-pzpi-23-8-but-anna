Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Катедра програмної інженерії



ЗВІТ
до практичного завдання № 2
з дисципліни «Аналіз та рефакторинґ коду»
на тему: «Методи рефакторингу коду програмного забезпечення за стандартами Microsoft C# Coding Conventions (Decompose Conditional, Hide Method, Replace Error Code with Exception)»




     Виконала
     ст. гр. ПЗПІ-23-8
     Бут Анна

     Перевірив
     ст. викладач катедри ПІ
     Сокорчук Ігор Петрович


Харків 2025
     1 ІСТОРІЯ ЗМІН
     
№ДатаВерсія звітуОпис змін та виправлень105.11.20250.1Створено розділ «Завдання»  206.11.20250.1Створено розділ «Опис виконаної роботи»308.11.20250.1Створено розділи «Висновки» та «Використані джерела»409.11.20250.1Створено додатки  «А», «Б» та  «В»     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     2 ЗАВДАННЯ
     Обрати три методи рефакторингу коду із книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code». Навести приклади свого особистого коду, який потребує покращення, та продемонструвати застосування обраних методів.
     Кожен метод рефакторингу повинен супроводжуватись:
* описом проблеми, яку вирішує даний метод;
* кодом до і після застосування методу рефакторингу;
* поясненням переваг використаного методу.





















3 ОПИС ВИКОНАНОЇ РОБОТИ
     3.1 Вступ

     Рефакторинг – це перетворення програмного коду, зміна внутрішньої структури програмного забезпечення для полегшення розуміння коду і внесення подальших змін без зміни зовнішньої поведінки самої системи.
     Основні цілі проведення рефакторингу включають: підвищення читабельності коду, зменшення його складності, поліпшення розширюваності, підвищення продуктивності та полегшення швидкого виконання програми.
     Чистий код проходить усі тести і є очевидним для інших програмістів завдяки зрозумілим іменам змінних та компактним класам і методам. Він не містить дублювання, що зменшує ймовірність помилок. 
     
     3.2 Метод «Decompose Conditional» («Розподіл умовного оператора»)
     3.2.1 Огляд методу «Decompose Conditional»
     
     Цей прийом рефакторингу застосовується тоді, коли в коді використовується складний або перевантажений умовний оператор if / else, який важко сприймається та аналізується. Суть методу полягає в розбитті такого умовного оператора на кілька окремих методів із зрозумілими та промовистими назвами. Це дозволяє підвищити читабельність коду, а також значно спростити його подальшу підтримку та модифікацію.
     
     3.2.2 Код до рефакторингу методом «Decompose Conditional»
     
     Програмний код до рефакторингу методом Decompose Conditional наведено в Додатку В.1.
     У наведеному коді реалізовано клас BonusCalculator, який містить метод CalculateBonus для обчислення розміру бонусу залежно від заробітної плати, стажу роботи та рейтингу продуктивності працівника. Для визначення бонусу використовується кілька рівнів умовних операторів if / else. Проблема полягає в тому, що через наявність вкладених умов складно швидко зрозуміти, за яких саме умов і який розмір бонусу нараховується. Логіка перевірки стажу та рейтингу продуктивності змішана з безпосереднім обчисленням бонусу, що знижує читабельність коду та ускладнює його підтримку. У разі необхідності розширення або зміни правил нарахування бонусів доведеться додавати нові умовні оператори, що ще більше ускладнить структуру методу та підвищить ризик помилок
     
     3.2.3 Код після рефакторингу методом «Decompose Conditional»
     
     Програмний код після рефакторингу методом «Decompose Conditional» наведено в Додатку В.2.
     Після застосування прийому рефакторингу «Decompose Conditional» («Розподіл умовного оператора») складна та вкладена умовна логіка була розділена на окремі методи з чіткими й зрозумілими назвами. Умови перевірки винесені в методи IsTopPerformer та IsGoodPerformer, а логіка обчислення бонусів – у методи HighBonus, MediumBonus і NoBonus. Завдяки цьому основний метод CalculateBonus став коротким і наочним, а логіка нарахування бонусу легко сприймається. 
     Перевагами цього методу «Decompose Conditional» є підвищення зрозумілості коду, а також спрощення його підтримки й модифікації. Крім того, навіть короткі логічні перевірки у вигляді методів є більш наочними, ніж складні вирази безпосередньо в умовах.

     3.3 Метод «Hide Method»(«Приховання методу»)
     3.3.1 Огляд методу «Hide Method»
     
     Метод «Hide Method» робить метод приватним або захищеним у випадках, коли він використовується лише всередині класу або його нащадків, приховуючи деталі реалізації від зовнішнього коду та підвищуючи рівень інкапсуляції. Це дозволяє чіткіше визначити публічний інтерфейс класу та зменшити залежність зовнішніх компонентів від внутрішньої реалізації.
     
     3.3.2 Код до рефакторингу методом «Hide Method»
     
     Програмний код до рефакторингу методом «Hide Method»наведено в Додатку В.3.
     Проблема: метод CalculateDiscount є публічним, хоча використовувався тільки всередині класу Order.  У результаті зовнішній код може викликати допоміжний метод без необхідності, що порушує принцип інкапсуляції та ускладнює підтримку й розвиток класу.
     
     3.3.3 Код після рефакторингу методом «Hide Method»
     
     Програмний код після рефакторингу методом «Hide Method» наведено в Додатку В.4.
     Після рефакторингу було змінено рівень доступу методу CalculateDiscount з public на private, оскільки він використовується виключно всередині класу Order. Це обмежило доступ до внутрішньої логіки обчислення знижки та запобігло її випадковому використанню ззовні класу. У результаті зменшився ризик помилкового виклику методу з інших частин програми, а публічний інтерфейс класу став чіткішим і зрозумілішим. Крім того, така зміна спрощує подальшу підтримку та розвиток класу, оскільки будь-які зміни в приватному методі впливатимуть лише на сам клас.
     Загальним правилом є прагнення робити кожен метод настільки приватним, наскільки це можливо, не порушуючи логіку роботи програми.
     
     
     
     3.4 Метод «Replace Error Code with Exception»( «Заміна коду помилки виключенням»)
     3.4.1 Огляд методу «Replace Error Code with Exception»
     
     Суть методу «Replace Error Code with Exception» полягає в тому, що замість повернення спеціальних значень або кодів для сигналізації про помилки метод «викидає» виключення. У сучасному об’єктно-орієнтованому програмуванні повернення числових або логічних кодів помилок вважається застарілим підходом, оскільки воно змушує додавати в код велику кількість умовних перевірок. Натомість при виникненні помилки метод «викидає» виключення, яке перехоплюється в спеціальному блоці try / catch, що чітко відокремлює шлях виконання програми від обробки помилок. Такий підхід спрощує логіку основного коду та дозволяє централізовано обробляти помилки.
     
     3.4.2 Код до рефакторингу методом «Replace Error Code with Exception»

     Програмний код до рефакторингу методом «Replace Error Code with Exception» наведено в Додатку В.5. 
     Проблема: метод Withdraw повертає числові коди помилок (0 – успіх, -1 – недостатньо коштів, -2 – неправильна сума), замість того щоб чітко сигналізувати про проблему через виключення. Це змушує зовнішній код постійно перевіряти значення, ускладнює читання та підтримку програми, а також не підходить для використання у конструкторах або більш складних потоках виконання.

     3.4.3 Код після рефакторингу методом «Replace Error Code with Exception»
     
     Програмний код після рефакторингу методом «Replace Error Code with Exception» наведено в Додатку В.6.
     У процесі рефакторингу числові коди помилок було замінено на виключення, тобто замість повернення значень метод Withdraw тепер «викидає» відповідні виключення ArgumentException та InvalidOperationException. Основна логіка роботи методу залишилася незмінною, проте обробка помилок стала більш наочною та безпечною. Виключення передають детальну інформацію про тип і причину помилки, що спрощує пошук і відстеження проблем у коді.
     При цьому важливо пам’ятати, що виключення не слід використовувати для управління виконанням коду. Виключення слід «викидати» тільки з метою повідомлення про помилку або критичну ситуацію.
     
     3.5  Інструменти для рефакторингу

     Сучасні середовища розробки надають потужні вбудовані інструменти для рефакторингу коду, які дозволяють значно спростити процес поліпшення структури програми та підвищення її читабельності. У C# середовище Visual Studio має власний набір рефакторингів, який включає функції Rename для безпечного перейменування змінних, методів і класів, Extract Method для виділення фрагментів коду в окремі методи, Encapsulate Field для створення getter і setter та Change Signature для зміни параметрів методів. Крім того, Visual Studio забезпечує набори правил для статичного аналізу коду та автоматичні пропозиції щодо покращення його якості.
     Roslyn Analyzers, інтегрований з компілятором C#, дозволяє виявляти порушення стилю, потенційні помилки, пропонує автоматичні рефакторинги та навіть дає можливість створювати власні правила для команди чи проєкту, що робить його ефективним інструментом для підтримки високої якості коду. 
     Для більш глибокого та інтелектуального рефакторингу розробники часто використовують платний плагін ReSharper від JetBrains, який інтегрується у Visual Studio і додає сотні швидких дій для поліпшення коду, покращену навігацію, статичний аналіз і підказки щодо оптимізації. Альтернативою є JetBrains Rider — окрема IDE, яка вбудовує можливості ReSharper та забезпечує швидшу роботу з проєктами на C#, .NET, Unity і ASP.NET, надаючи повний набір інструментів для безпечного рефакторингу.
ВИСНОВКИ

     У ході виконаної роботи було розглянуто основні принципи рефакторингу та методи поліпшення якості програмного коду, а також сучасні інструменти, що підтримують процес рефакторингу. Було вивчено застосування методів Decompose Conditional, Hide Method та Replace Error Code with Exception, які сприяють підвищенню читабельності, безпечності та підтримуваності програм. На практичних прикладах продемонстровано, як рефакторинг дозволяє спростити логіку коду, покращити інкапсуляцію та зробити обробку помилок більш зрозумілою. Отримані результати підтверджують, що регулярне застосування рефакторингу є важливим етапом у розробці якісного та надійного програмного забезпечення.


















ВИКОРИСТАННІ ДЖЕРЕЛА

     1. Рефакторинг і Патерни проектування. Refactoring and Design Patterns. URL: https://refactoring.guru/uk (дата звернення: 9.11.2025).
     2. GitHub - Gatjuat-Wicteat-Riek/clean-code-book: Here is the PDF version of the book "Clean Code" by Robert C. Martin. A must read books for upcoming (and senior) developers who want to learn how to write masterpieces and not just lines of code :). GitHub. URL: https://github.com/Gatjuat-Wicteat-Riek/clean-code-book (дата звернення: 9.11.2025).
     3.  Martin Fowler. Refactoring. Improving the Design of Existing Code– Addison-Wesley Professional, 1999. – 464 p.



















ДОДАТОК А
Відеозапис

Відеозапис доповіді: https://youtu.be/XOQBKAJWdzM
Хронологічний опис відеозапису:
00:00 – Вступ
00:59 – Огляд методу «Decompose Conditional» 
01:42 – Код до рефакторингу методом «Decompose Conditional» 
02:27 – Код після рефакторингу методом «Decompose Conditional» 
03:03 – Огляд методу «Hide Method» 
03:25 – Код до рефакторингу методом «Hide Method» 
03:51 – Код після рефакторингу методом «Hide Method» 
04:32 – Огляд методу «Replace Error Code with Exception»
05:14 – Код до рефакторингу методом «Replace Error Code with Exception» 
05:51 – Код після рефакторингу методом «Replace Error Code with Exception» 
06:28 – Інструменти для рефакторингу 
07:52 – Висновки 
08:22 – Використані джерела












ДОДАТОК Б
Слайди презентації

 
Рисунок Б.1 – Титульний слайд


Рисунок Б.2 – Огляд теми

Рисунок Б.3 – Огляд методу «Decompose Conditional»


Рисунок Б.4 – Програмний код до рефакторингу методом «Decompose Conditional»



Рисунок Б.5 – Програмний код після рефакторингу методом «Decompose Conditional» 


Рисунок Б.6 – Огляд методу «Hide Method»


Рисунок Б.7 – Програмний код до рефакторингу методом «Hide Method» 


Рисунок Б.8 – Програмний код після рефакторингу методом «Hide Method» 


Рисунок Б.9 – Огляд методу «Replace Error Code with Exception»


Рисунок Б.10 – Програмний код після рефакторингу методом «Replace Error Code with Exception» 

Рисунок Б.11 – Програмний код після рефакторингу методом «Replace Error Code with Exception» 


Рисунок Б.12 – Огляд  інструментів для рефакторингу

Рисунок Б.13 – Висновки 

 
Рисунок Б.14 – Використані джерела



ДОДАТОК В

     В.1 Приклад коду до рефакторингу методом «Decompose Conditional»
     
     GitHub репозиторій: https://github.com/NureButAnna/ark-pzpi-23-8-but-anna/blob/main/Pract2/apz-pzpi-23-8-but-anna-pract2/RefactoringExamples.cs
     
1 public class BonusCalculator
2 {
3     public double CalculateBonus(double salary, int yearsOfExperience, double performanceRating)
4     {
5         double bonus;
6 
7         if (yearsOfExperience > 5 && performanceRating >= 4.5)
8         {
9             bonus = salary * 0.2;
10         }
11         else
12         {
13             if (performanceRating >= 4.0)
14             {
15                 bonus = salary * 0.1;
16             }
17             else
18             {
19                 bonus = 0;
20             }
21         }
22 
23         return bonus;
24     }
     
     
     
     
     
     

     В.2 Приклад коду після рефакторингу методом «Decompose Conditional»
     
     GitHub репозиторій: https://github.com/NureButAnna/ark-pzpi-23-8-but-anna/blob/main/Pract2/apz-pzpi-23-8-but-anna-pract2/RefactoringExamples.cs
     
1 public class BonusCalculator
2 {
3     public double CalculateBonus(double salary, int yearsOfExperience, double performanceRating)
4     {
5         if (IsTopPerformer(yearsOfExperience, performanceRating))
6             return HighBonus(salary);
7         else if (IsGoodPerformer(performanceRating))
8             return MediumBonus(salary);
9         else
10             return NoBonus();
11     }
12 
13     private bool IsTopPerformer(int yearsOfExperience, double performanceRating)
14     {
15         return yearsOfExperience > 5 && performanceRating >= 4.5;
16     }
17 
18     private bool IsGoodPerformer(double performanceRating)
19     {
20         return performanceRating >= 4.0;
21     }
22 
23     private double HighBonus(double salary)
24     {
25         return salary * 0.2;
26     }
27 
28     private double MediumBonus(double salary)
29     {
30         return salary * 0.1;
31     }
32 
33     private double NoBonus()
34     {
35         return 0;
36     }
37 }


     В.3 Приклад коду до рефакторингу методом «Hide Method»
     
     GitHub репозиторій: https://github.com/NureButAnna/ark-pzpi-23-8-but-anna/blob/main/Pract2/apz-pzpi-23-8-but-anna-pract2/RefactoringExamples.cs
1 public class Order
2 {
3     public double CalculateTotal(double amount)
4     {
5         double discount = CalculateDiscount(amount);
6         return amount - discount;
7     }
8 
9     public double CalculateDiscount(double amount)
10     {
11         if (amount > 1000)
12             return amount * 0.1;
13         else
14             return 0;
15     }
16 }
      
     В.4 Приклад коду після рефакторингу методом «Hide Method»
     
     GitHub репозиторій: https://github.com/NureButAnna/ark-pzpi-23-8-but-anna/blob/main/Pract2/apz-pzpi-23-8-but-anna-pract2/RefactoringExamples.cs

1 public class Order
2 {
3     public double CalculateTotal(double amount)
4     {
5         double discount = CalculateDiscount(amount);
6         return amount - discount;
7     }
8 
9     private double CalculateDiscount(double amount)
10     {
11         if (amount > 1000)
12             return amount * 0.1;
13         else
14             return 0;
15     }
16 }
      
     В.5 Приклад коду до рефакторингу методом «Replace Error Code with Exception»
     
     GitHub репозиторій: https://github.com/NureButAnna/ark-pzpi-23-8-but-anna/blob/main/Pract2/apz-pzpi-23-8-but-anna-pract2/RefactoringExamples.cs

1 public class BankAccount
2 {
3     private double _balance;
4 
5     public BankAccount(double initialBalance)
6     {
7         _balance = initialBalance;
8     }
9 
10     // Повертає 0 – успіх, -1 – недостатньо коштів, -2 – неправильна сума
11     public int Withdraw(double amount)
12     {
13         if (amount <= 0)
14         {
15             return -2;
16         }
17         if (amount > _balance)
18         {
19             return -1;
20         }
21 
22         _balance -= amount;
23         return 0;
24     }
25 
26     public double GetBalance()
27     {
28         return _balance;
29     }
30 }
      
      
      
      
      
      
      
      
      
      
      
      
      
     В.6 Приклад коду після рефакторингу методом «Replace Error Code with Exception»
     
     
     GitHub репозиторій: https://github.com/NureButAnna/ark-pzpi-23-8-but-anna/blob/main/Pract2/apz-pzpi-23-8-but-anna-pract2/RefactoringExamples.cs

1 public class BankAccount
2 {
3     private double _balance;
4 
5     public BankAccount(double initialBalance)
6     {
7         _balance = initialBalance;
8     }
9 
10     public void Withdraw(double amount)
11     {
12         if (amount <= 0)
13         {
14             throw new ArgumentException("Сума повинна бути більшою за нуль.");
15         }
16         if (amount > _balance)
17         {
18             throw new InvalidOperationException("Недостатньо коштів на рахунку.");
19         }
20 
21         _balance -= amount;
22     }
23 
24     public double GetBalance()
25     {
26         return _balance;
27     }
     
2


